(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
var ajax;

ajax = require('./myAjax');

exports.get = function(data, callback) {
  var ajaxRequest, ajaxTarget, ajaxVerb;
  ajaxTarget = location.protocol + '//' + location.hostname;
  ajaxVerb = 'getData';
  ajaxRequest = ajaxTarget + '/' + ajaxVerb + '?' + 'data=' + data;
  return ajax.go(ajaxRequest, null, function(response) {
    return callback(response);
  });
};

},{"./myAjax":4}],2:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
var TOCTokens, TitleChooser, articleSelectorPaneHeight, articles, boxH, calcEnd, calcStart, categorizedTextTree, colors, coreH, currentArticle, data, end, firstEntry, globalDims, layout, navBars, navBarsTree, panes, sceneDefine, sceneHook, sceneObject, sceneSync, segments, session, start, states, subCategoriesNavigation, svgUtil, syncInit, textDraw, tokenize, tokens, util, viewport, waitForData;

util = require('./util');

panes = require('./panes');

data = require('./data');

tokenize = require('./tokenize');

textDraw = require('./textDraw');

svgUtil = require('./svgUtil');

session = require('./session');

globalDims = require('./globalDims');

sceneObject = globalDims.sceneObject;

layout = globalDims.layout;

sceneHook = globalDims.sceneHook;

subCategoriesNavigation = false;

if (subCategoriesNavigation) {
  navBars = require('./navBarsSubMode');
} else {
  navBars = require('./navBars');
}

console.log('read.js main started');

firstEntry = true;

viewport = null;

states = {
  rightPane: 'toc-invitation',
  articleSwitcher: false
};

colors = {
  scaleStart: '#87CEFA',
  scaleEnd: '#00BFFF'
};

tokens = void 0;

TOCTokens = [];

navBarsTree = void 0;

categorizedTextTree = void 0;

segments = void 0;

calcStart = function() {
  return 90;
};

calcEnd = function() {
  return 90;
};

layout = {
  'separator': {
    'left': {
      'x': {
        'current': 300
      }
    }
  }
};

layout.separator.left.x.revertsTo = layout.separator.left.x.current;

layout.separator.top = {};

coreH = null;

boxH = null;

end = null;

articles = ["The Relationship Between Human Capital and Firm Performance", "Article 2", "Article 3"];

currentArticle = 0;

articleSelectorPaneHeight = calcStart() - 5 - 5;

/(?:)/;

/(?:)/;

/(?:)/;

TitleChooser = function() {
  var chooserClose, height, titlePanes;
  states.articleSwitcher = true;
  titlePanes = [];
  height = {
    'selectorMode': articles.length * articleSelectorPaneHeight,
    'selectedMode': articleSelectorPaneHeight
  };
  chooserClose = function() {
    var article, i, _i, _len;
    console.log('closing article chooser');
    sceneObject.topPane.transition().duration(400).ease('sin').attr('height', height.selectedMode);
    for (i = _i = 0, _len = articles.length; _i < _len; i = ++_i) {
      article = articles[i];
      titlePanes[i].element.remove();
    }
    return states.articleSwitcher = false;
  };
  console.log('opening article chooser');
  util.makeSvgTopLayer(sceneObject.topPaneGroup.node());
  sceneObject.titlePort.textWrapper.transition().duration(450).styleTween('-webkit-transform', function() {
    return d3.interpolateString('perspective(40px) rotate3d(1, 0, 0, 2deg)', 'perspective(40px) rotate3d(1, 0, 0, 0deg)');
  });
  sceneObject.topPane.transition().duration(450).ease('linear').attr('height', height.selectorMode).each("end", function() {
    var a, article, hoverHandler, i, pane, switchPanes, _i, _len, _results;
    switchPanes = function(oldSelected, newSelected) {
      var yNewPane, yNewText, yOldPane, yOldText;
      yOldPane = oldSelected.pane.attr('y');
      yNewPane = newSelected.pane.attr('y');
      yOldText = oldSelected.text.attr('y');
      yNewText = newSelected.text.attr('y');
      oldSelected.pane.transition().duration(450).delay(250).attr('y', yNewPane);
      oldSelected.text.transition().duration(450).delay(250).attr('y', yNewText);
      newSelected.pane.transition().duration(450).attr('y', yOldPane);
      newSelected.text.transition().duration(450).attr('y', yOldText);
      oldSelected.pane.node().style.fill = '#50BFEF';
      return newSelected.pane.node().style.fill = '#60CBFE';
    };
    hoverHandler = function(eventPane, i) {
      eventPane.pane.node().style.fill = '#55C4F5';
      eventPane.pane.node().onmouseout = function() {
        return eventPane.pane.node().style.fill = '#50BFEF';
      };
      return eventPane.pane.node().onclick = function() {
        console.log("article " + articles[currentArticle] + " selected");
        switchPanes(titlePanes[currentArticle], titlePanes[i]);
        return currentArticle = i;
      };
    };
    _results = [];
    for (i = _i = 0, _len = articles.length; _i < _len; i = ++_i) {
      article = articles[i];
      if (i === currentArticle) {
        titlePanes.push(panes.titlePaneCreate(sceneObject.topPaneGroup, '#60CBFE', true));
      } else {
        titlePanes.push(panes.titlePaneCreate(sceneObject.topPaneGroup, '#50BFEF'));
      }
      pane = titlePanes[i];
      pane.text.text(article);
      pane.pane.attr('width', viewport.width - 5 - 5).attr('height', layout.separator.top.y - 5 - 5).attr('x', 5).attr('y', 5 + (i * articleSelectorPaneHeight)).style('stroke-width', '7px').attr('rx', 10).attr('rx', 10);
      pane.text.attr('x', viewport.width / 2).attr('y', 5 + (i + 0.5) * articleSelectorPaneHeight).style('font-family', 'Helvetica').style("font-weight", "bold").attr("font-size", "30px");
      if (i !== currentArticle) {
        a = hoverHandler.bind(void 0, pane, i);
        _results.push(pane.pane.node().onmouseover = a);
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  });
  return sceneObject.topPaneGroup.on('mouseleave', function() {
    console.log('mouse outside title port');
    return chooserClose();
  });
};

sceneDefine = function() {
  var TOC, downButton, fontSizeButton, mainPanes, navBarHook, rightPane, textPort, titlePort;
  TOC = function() {
    var fontFamily, fontSize, maxLen, token, tokenViewable, _i, _len;
    sceneObject.TOC = {};
    fontSize = '14px';
    fontFamily = 'verdana';
    sceneObject.TOC.element = sceneHook.svg.append('svg');
    sceneObject.TOC.subElement = sceneObject.TOC.element.append('g').style('text-anchor', 'start').style('fill', '#60cafb').style('font-family', fontFamily).style('font-size', fontSize);
    maxLen = 0;
    for (_i = 0, _len = TOCTokens.length; _i < _len; _i++) {
      token = TOCTokens[_i];
      tokenViewable = textDraw.tokenToViewable(token.text, sceneObject.TOC.element);
      if (tokenViewable.width > maxLen) {
        maxLen = tokenViewable.width;
      }
    }
    sceneObject.TOC.geometry = {
      paddingX: 30
    };
    return sceneObject.TOC.geometry.width = maxLen + (2 * sceneObject.TOC.geometry.paddingX);
  };
  mainPanes = function(categories) {
    var colorScale, colorTransition, numberOfBoxes;
    numberOfBoxes = categories.length;
    colorScale = d3.scale.linear().domain([0, numberOfBoxes - 1]).range([colors.scaleStart, colors.scaleEnd]);
    return colorTransition = function(i) {
      return function() {
        return d3.select(this).transition().duration(25).ease('circle').style('fill', colorScale(i));
      };
    };
  };
  textPort = function() {
    sceneObject.textPortBoundary = {};
    sceneObject.textPortBoundary.element = sceneHook.svg.append('rect').style('stroke', '#999999').style('fill', '#999999').on('mouseover', function() {
      return this.style.cursor = "ew-resize";
    }).on('mouseout', function() {
      return this.style.cursor = "default";
    }).on('mousedown', function() {
      var element, rightInitialSeparator, widthInitialBoundary, widthInitialText, xInitial;
      this.style.cursor = "ew-resize";
      xInitial = event.clientX;
      widthInitialBoundary = sceneObject.textPortBoundary.element.attr('width');
      widthInitialText = sceneObject.textPort.element.attr('width');
      rightInitialSeparator = layout.separator.right.x;
      element = d3.select(this);
      window.onmousemove = function(event) {
        var xDiff;
        xDiff = xInitial - event.clientX;
        layout.separator.right.x = rightInitialSeparator - xDiff;
        layout.separator.right.y = rightInitialSeparator - xDiff;
        sceneObject.textPortBoundary.element.attr('width', widthInitialBoundary - xDiff);
        sceneObject.textPort.element.attr('width', widthInitialText - xDiff);
        navBars.textportRefresh();
        sceneObject.rightPane.redraw();
        return sceneObject.downButton.redraw();
      };
      window.onmouseup = function(event) {
        window.onmousemove = null;
        event.target.style.cursor = "default";
        return element.transition().duration(500).style('stroke', '#999999');
      };
      element.transition().duration(300).style('stroke', '#aaaaaa');
    }).on('touchstart', function() {
      var element, widthInitialBoundary, widthInitialText, xInitial;
      element = d3.select(this);
      element.transition().duration(900).style('stroke', '#FFEEBB');
      xInitial = event.changedTouches[0].clientX;
      widthInitialBoundary = sceneObject.textPortBoundary.element.attr('width');
      widthInitialText = sceneObject.textPort.element.attr('width');
      window.ontouchmove = function(event) {
        var xDiff;
        xDiff = xInitial - event.changedTouches[0].clientX;
        sceneObject.textPortBoundary.element.attr('width', widthInitialBoundary - xDiff);
        sceneObject.textPort.element.attr('width', widthInitialText - xDiff);
        return navBars.textportRefresh();
      };
      window.ontouchcancel = function() {
        window.ontouchmove = null;
        return element.transition().duration(600).style('stroke', '#999999');
      };
      window.ontouchleave = function() {
        window.ontouchmove = null;
        return element.transition().duration(600).style('stroke', '#999999');
      };
      return window.ontouchend = function() {
        window.ontouchmove = null;
        return element.transition().duration(600).style('stroke', '#999999');
      };
    });
    sceneObject.textPort = {};
    return sceneObject.textPort.element = sceneHook.svg.append('rect').style('stroke', '#222222').style('fill', '#222222');
  };
  titlePort = function() {
    sceneObject.topPaneGroup = sceneHook.svg.append('g');
    sceneObject.topPane = sceneObject.topPaneGroup.append('rect').style('fill', '#60CAFB');
    sceneObject.titlePort = panes.titlePaneCreate(sceneObject.topPaneGroup, '#60CAFB', true);
    sceneObject.titlePort.text.text(articles[currentArticle]);
    return sceneObject.topPaneGroup.on('mouseover', function() {
      console.log('mouseover titleport');
      if (!states.articleSwitcher) {
        return TitleChooser();
      }
    });
  };
  rightPane = function() {
    var styles, textRect;
    styles = {
      rectangle: {
        'fill': '#999999',
        'fill-opacity': '0.5'
      },
      text: {
        'font-family': 'verdana',
        'fill': '#909092',
        'font-weight': 'bold',
        'font-size': '35px'
      }
    };
    textRect = svgUtil.textRectFactory(sceneHook.svg, 'More', styles, 'visible');
    sceneObject.rightPane = {
      element: textRect.rectangle,
      textElem: textRect.text
    };
    sceneObject.rightPane.geometry = {};
    sceneObject.rightPane.geometry = {
      'hoverIgnoreAreaX': void 0,
      'hoverIgnoreAreaY': void 0
    };
    sceneObject.rightPane.element.on('mouseover', function() {
      console.log('mouseover');
      return sceneObject.rightPane.element.on('mousemove', function() {
        if (event.x > layout.separator.right.x + sceneObject.rightPane.geometry.hoverIgnoreAreaX) {
          if (event.y > layout.separator.top.y + sceneObject.rightPane.geometry.hoverIgnoreAreaY && event.y < viewport.height - sceneObject.rightPane.geometry.hoverIgnoreAreaY) {
            sceneObject.rightPane.element.on('mousemove', null);
            sceneObject.rightPane.mode = 'animate';
            sceneObject.textPortBoundary.mode = 'animate';
            sceneObject.textPort.mode = 'animate';
            layout.separator.right.x = viewport.width - sceneObject.TOC.geometry.width;
            states.rightPane = 'toc-unveiling';
            return sceneSync('animate');
          }
        }
      });
    });
    return sceneObject.rightPane.redraw = function() {
      var middle;
      console.log('rightpane redraw started');
      sceneObject.rightPane.geometry = {
        'hoverIgnoreAreaX': (viewport.width - layout.separator.right.x) / 3,
        'hoverIgnoreAreaY': (viewport.height - layout.separator.top.y) / 3
      };
      sceneObject.rightPane.geometry.width = viewport.width - layout.separator.right.x;
      /*
      if states.rightPane is 'in progress'
        sceneObject.rightPane.geometry.width = sceneObject.TOC.geometry.width
      else 
        sceneObject.rightPane.geometry.width = viewport.width - (layout.separator.right.x)
      */

      sceneObject.rightPane.geometry.x = layout.separator.right.x;
      sceneObject.rightPane.geometry.y = layout.separator.top.y;
      sceneObject.rightPane.geometry.height = coreH;
      middle = function(point, lengthFrom) {
        return parseFloat(point + (lengthFrom / 2));
      };
      sceneObject.rightPane.textElem.attr('x', middle(sceneObject.rightPane.geometry.x, sceneObject.rightPane.geometry.width)).attr('y', middle(sceneObject.rightPane.geometry.y, sceneObject.rightPane.geometry.height));
      switch (states.rightPane) {
        case 'toc-unveiling':
          sceneObject.rightPane.textElem.attr('visibility', 'hidden');
          svgUtil.sync(sceneObject.rightPane, sceneObject.TOC.redraw);
          return states.rightPane = 'toc-on';
        case 'toc-on':
          sceneObject.TOC.subElement.remove();
          return sceneObject.TOC.redraw();
        default:
          return svgUtil.sync(sceneObject.rightPane);
      }
    };
  };
  sceneHook.svg = d3.select('body').append('svg').style('background-color', '#999999');
  sceneObject.categories = {};
  navBarHook = sceneHook.svg.append('g');
  rightPane();
  textPort();
  navBars.init(navBarsTree, navBarHook, categorizedTextTree);
  titlePort();
  TOC();
  fontSizeButton = function() {
    sceneObject.fontSize = {
      element: sceneHook.svg.append("g")
    };
    sceneObject.fontDecreaseButton = sceneObject.fontSize.element.append("svg:image").attr("xlink:href", "fontSmall.svg");
    sceneObject.fontIncreaseButton = sceneObject.fontSize.element.append("svg:image").attr("xlink:href", "fontLarge.svg");
    sceneObject.fontDecreaseButton.on('mouseover', function() {
      return console.log('hover');
    }).on('mousedown', function() {
      console.log('click font decrease');
      return navBars.textportRefresh(-2);
    });
    return sceneObject.fontIncreaseButton.on('mouseover', function() {
      return console.log('hover');
    }).on('mousedown', function() {
      console.log('click font increase');
      return navBars.textportRefresh(2);
    });
  };
  fontSizeButton();
  downButton = function() {
    sceneObject.downButton = {};
    sceneObject.downButton.geometry = {
      'paddingY': 15,
      'paddingX': 30,
      'height': 25
    };
    return sceneObject.downButton.element = sceneHook.svg.append('svg:image').attr('xlink:href', 'images/downScroll6.svg').attr('preserveAspectRatio', 'none').on('mouseover', function() {
      return sceneObject.downButton.element.transition().ease('sin').duration(400).attr('height', sceneObject.downButton.geometry.height + (sceneObject.downButton.geometry.paddingY * 2 / 3));
    }).on('mouseout', function() {
      return sceneObject.downButton.element.transition().duration(300).attr('height', sceneObject.downButton.geometry.height);
    }).on('mousedown', function() {
      console.log('scroll');
      return navBars.textportRefresh(0, true);
    });
  };
  return downButton();
};

sceneSync = function(mode) {
  var autoUpdate, drawTitle, leftPane, update;
  viewport = util.getViewport();
  layout.separator.top = {
    'y': calcStart()
  };
  end = 0;
  coreH = viewport.height - layout.separator.top.y - end;
  sceneHook.svg.attr('width', viewport.width).attr('height', viewport.height);
  if (layout.separator.right == null) {
    layout.separator.right = {
      'x': viewport.width - layout.separator.left.x.current
    };
  }
  sceneObject.textPortBoundary.geometry = {
    'x': layout.separator.left.x.current,
    'width': layout.separator.right.x - layout.separator.left.x.current,
    'y': layout.separator.top.y + 5,
    'height': coreH
  };
  sceneObject.textPortBoundary.style = {
    'stroke-width': '25px'
  };
  svgUtil.sync(sceneObject.textPortBoundary);
  sceneObject.textPort.geometry = {
    'x': layout.separator.left.x.current + 5,
    'width': layout.separator.right.x - layout.separator.left.x.current - 10,
    'height': coreH,
    'y': layout.separator.top.y + 5 + 10,
    'rx': 10,
    'rx': 10
  };
  sceneObject.textPort.style = {
    'stroke-width': '15px'
  };
  svgUtil.sync(sceneObject.textPort);
  sceneObject.fontSize.redraw = function() {
    var fontButtonGeometry;
    console.log('redrawing font size buttons');
    fontButtonGeometry = {
      'width': 398 * 0.08,
      'height': 624 * 0.08
    };
    sceneObject.fontDecreaseButton.attr('x', viewport.width - (fontButtonGeometry.width * 2) - 7).attr('y', layout.separator.top.y - fontButtonGeometry.height - 7).attr('width', fontButtonGeometry.width).attr('height', fontButtonGeometry.height);
    return sceneObject.fontIncreaseButton.attr('x', viewport.width - fontButtonGeometry.width - 7 - 1).attr('y', layout.separator.top.y - fontButtonGeometry.height - 7).attr('width', fontButtonGeometry.width).attr('height', fontButtonGeometry.height);
  };
  sceneObject.fontSize.redraw();
  drawTitle = function() {
    sceneObject.titlePort.pane.attr('width', viewport.width - 5 - 5).attr('height', layout.separator.top.y - 5 - 5).attr('x', 5).attr('y', -50).style('stroke-width', '7px').attr('rx', 10).attr('rx', 10);
    sceneObject.titlePort.textWrapper.attr('width', viewport.width - 5 - 5).attr('height', articleSelectorPaneHeight);
    sceneObject.titlePort.text.attr('x', viewport.width / 2).attr('y', 0).style('font-family', 'Helvetica').style("font-weight", "bold").attr("font-size", "30px");
    if (firstEntry) {
      sceneObject.titlePort.text.transition().duration(300).ease('sin').attr('y', layout.separator.top.y / 2);
      sceneObject.titlePort.pane.transition().duration(300).ease('sin').attr('y', 5);
      firstEntry = false;
    } else {
      sceneObject.titlePort.text.attr('y', layout.separator.top.y / 2);
      sceneObject.titlePort.pane.attr('y', 5);
    }
    return sceneObject.topPane.attr('width', viewport.width - 5 - 5).attr('height', layout.separator.top.y - 5 - 5).attr('x', 5).attr('y', 5).style('stroke-width', '7px').attr('rx', 10).attr('rx', 10);
  };
  drawTitle();
  if (tokens != null) {
    switch (mode) {
      case 'animate':
        update = 0;
        autoUpdate = setInterval((function() {
          navBars.textportRefresh();
          if (update > 8) {
            setTimeout(window.clearInterval(autoUpdate), 400);
          }
          return update += 1;
        }), 50);
        break;
      default:
        navBars.textportRefresh();
    }
  }
  sceneObject.downButton.redraw = function() {
    sceneObject.downButton.geometry.width = (layout.separator.right.x - layout.separator.left.x.current) / 5;
    sceneObject.downButton.geometry.x = layout.separator.left.x.current + (((layout.separator.right.x - layout.separator.left.x.current) - sceneObject.downButton.geometry.width) / 2);
    sceneObject.downButton.geometry.y = sceneHook.svg.attr('height') - sceneObject.downButton.geometry.height - sceneObject.downButton.geometry.paddingY;
    return sceneObject.downButton.element.attr('x', sceneObject.downButton.geometry.x).attr('width', sceneObject.downButton.geometry.width).attr('y', sceneObject.downButton.geometry.y).attr('height', sceneObject.downButton.geometry.height);
  };
  sceneObject.downButton.redraw();
  sceneObject.rightPane.redraw();
  leftPane = {
    geometry: {
      x: 0,
      width: layout.separator.left.x.current - 10,
      y: layout.separator.top.y + 7,
      height: coreH - 2
    }
  };
  navBars.redraw(leftPane.geometry);
  return sceneObject.TOC.redraw = function() {
    var TOCToken, lHeight, lineSpacing, paddingX, paddingY, spaceWidth, tokenViewable, viewPortFull, x, y, _i, _len, _results;
    lineSpacing = 5;
    console.log('redraw toc started');
    spaceWidth = textDraw.tokenToViewable('a a', sceneObject.TOC.subElement).width - textDraw.tokenToViewable('aa', sceneObject.TOC.subElement).width;
    lHeight = textDraw.tokenToViewable('l', sceneObject.TOC.subElement).height;
    paddingX = 20;
    paddingY = 10;
    sceneObject.TOC.element.attr('x', parseFloat(sceneObject.rightPane.element.attr('x')) + paddingX).attr('width', parseFloat(sceneObject.rightPane.element.attr('width') - (paddingX * 2))).attr('y', parseFloat(sceneObject.rightPane.element.attr('y')) + paddingY).attr('height', parseFloat(sceneObject.rightPane.element.attr('height') - (paddingY * 2)));
    viewPortFull = false;
    y = 0;
    _results = [];
    for (_i = 0, _len = TOCTokens.length; _i < _len; _i++) {
      TOCToken = TOCTokens[_i];
      x = paddingX;
      tokenViewable = textDraw.tokenToViewable(TOCToken.text, sceneObject.TOC.subElement);
      switch (TOCToken.level) {
        case 1:
          x += 0;
          break;
        case 2:
          x += 15;
          break;
        case 3:
          x += 30;
      }
      if (y + tokenViewable.height + lHeight < sceneObject.TOC.element.attr('y') + sceneObject.TOC.element.attr('height')) {
        y += tokenViewable.height + lineSpacing;
        tokenViewable.svg.attr('x', x);
        tokenViewable.svg.attr('y', y);
        x += tokenViewable.width;
      } else {
        viewPortFull = true;
        break;
      }
      _results.push(x += spaceWidth);
    }
    return _results;
  };
};

data.get('introduction', function(response) {
  return tokens = tokenize(response);
});

data.get('abstract', function(response) {
  var rawSegment, rawSegments, segment, _i, _len, _results;
  rawSegments = JSON.parse(response).segments;
  segments = [];
  _results = [];
  for (_i = 0, _len = rawSegments.length; _i < _len; _i++) {
    rawSegment = rawSegments[_i];
    segment = new Object;
    segment.category = rawSegment.category;
    segment.tokens = rawSegment.text.split(' ');
    _results.push(segments.push(segment));
  }
  return _results;
});

data.get('categories', function(response) {
  return navBarsTree = JSON.parse(response).root;
});

data.get('text', function(response) {
  return categorizedTextTree = JSON.parse(response).root;
});

data.get('TOC', function(response) {
  var rawTOC, rawToken, token, _i, _len, _ref, _results;
  rawTOC = JSON.parse(response);
  _ref = rawTOC.entries;
  _results = [];
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    rawToken = _ref[_i];
    token = {
      'level': rawToken[0],
      'text': rawToken[1]
    };
    _results.push(TOCTokens.push(token));
  }
  return _results;
});

syncInit = function() {
  sceneSync();
  return window.onresize = function() {
    return sceneSync();
  };
};

start = function() {
  sceneDefine();
  syncInit();
  console.dir(viewport);
  return document.body.style.cursor = "default";
};

waitForData = setInterval((function() {
  if ((tokens != null) && (TOCTokens != null) && (segments != null) && (navBarsTree != null) && (categorizedTextTree != null)) {
    window.clearInterval(waitForData);
    return start();
  }
}), 50);

},{"./data":1,"./globalDims":3,"./navBars":5,"./navBarsSubMode":6,"./panes":7,"./session":8,"./svgUtil":9,"./textDraw":10,"./tokenize":13,"./util":14}],3:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
exports.layout = {};

exports.sceneObject = {};

exports.sceneHook = {};

},{}],4:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
exports.go = function(url, postData, callback) {
  var ajaxRequest;
  ajaxRequest = new XMLHttpRequest();
  console.log('Making ajax call to ' + url);
  ajaxRequest.onreadystatechange = function() {
    if (ajaxRequest.readyState === 4) {
      if (ajaxRequest.status === 200) {
        console.log('Ajax call to ' + url + ' succeeded.');
        return callback(ajaxRequest.responseText);
      } else {
        return console.error('Ajax call to ' + url + ' failed');
      }
    }
  };
  if (postData != null) {
    console.log('ajax request includes post data');
    ajaxRequest.open('POST', url, false);
    ajaxRequest.setRequestHeader("Content-type", "application/json");
    return ajaxRequest.send(postData);
  } else {
    ajaxRequest.open('GET', url, true);
    return ajaxRequest.send(null);
  }
};

},{}],5:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
var barUnselect, bars, categorizedTextTree, colors, getCategoryText, globalDims, layout, lookup, redraw, root, sceneObject, searchCategories, session, sessionSetDisplayType, svgUtil, textRectFactory, textportFluent, textportRefresh, textportSegmented, tokenize, util;

util = require('./util');

svgUtil = require('./svgUtil');

textportFluent = require('./textportFluent');

textportSegmented = require('./textportSegmented');

session = require('./session');

tokenize = require('./tokenize');

globalDims = require('./globalDims');

sceneObject = globalDims.sceneObject;

layout = globalDims.layout;

bars = [];

root = {};

lookup = {};

colors = {
  scaleStart: '#999999',
  scaleEnd: '#999999',
  selection: '#60cafb'
};

categorizedTextTree = void 0;

textRectFactory = function(svgHookPoint, rectText) {
  var styles;
  styles = {
    text: {
      'font-family': 'verdana',
      'fill': '#EEEEEE',
      'font-weight': 'bold'
    },
    rectangle: {
      'stroke-width': '0px',
      'fill-opacity': '1'
    }
  };
  return svgUtil.textRectFactory(svgHookPoint, rectText, styles, 'hidden');
};

searchCategories = function(categoryNodes, catName) {
  var categoryNode, _i, _len;
  for (_i = 0, _len = categoryNodes.length; _i < _len; _i++) {
    categoryNode = categoryNodes[_i];
    if (categoryNode.name === catName) {
      return categoryNode.text;
    } else {
      if (categoryNode.subs != null) {
        if (searchCategories(categoryNode.subs, catName)) {
          return searchCategories(categoryNode.subs, catName);
        }
      }
    }
  }
  return false;
};

getCategoryText = function(catName) {
  var text;
  return text = searchCategories(categorizedTextTree, catName);
};

textportRefresh = function(fontSizeChange, scroll, mode) {
  var categoryNode, downArrowNeeded, rawSegment, rawTextArray, segment, segments, _i, _j, _len, _len1;
  switch (session.display) {
    case 'segmented':
      for (_i = 0, _len = categorizedTextTree.length; _i < _len; _i++) {
        categoryNode = categorizedTextTree[_i];
        if (categoryNode.name === session.selected.name) {
          rawTextArray = categoryNode.text;
        }
      }
      segments = [];
      for (_j = 0, _len1 = rawTextArray.length; _j < _len1; _j++) {
        rawSegment = rawTextArray[_j];
        segment = {
          category: null,
          tokens: tokenize(rawSegment)
        };
        segments.push(segment);
      }
      return textportSegmented(segments, fontSizeChange, scroll, mode);
    case 'fluent':
      return downArrowNeeded = textportFluent(categorizedTextTree, fontSizeChange, scroll, mode);
  }
};

exports.textportRefresh = textportRefresh;

sessionSetDisplayType = function(bar) {
  if (bar.display === 'segmented') {
    return session.display = 'segmented';
  } else {
    return session.display = 'fluent';
  }
};

barUnselect = function(bar) {
  var hideChildren;
  hideChildren = function(bar) {
    var child, _i, _len, _ref, _results;
    if (bar.children != null) {
      _ref = bar.children;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        child = _ref[_i];
        child.viewStatus = 'hidden';
        child.element.group.attr('visibility', 'hidden');
        _results.push(hideChildren(child));
      }
      return _results;
    }
  };
  bar.viewStatus = 'visible';
  return hideChildren(bar);
};

exports.init = function(navBarsData, svgHookPoint, categorizedTextTreeInput) {
  var bar, barCreate, barData, colorScale, i, initialViewStatus, _i, _j, _len, _len1, _results;
  categorizedTextTree = categorizedTextTreeInput;
  console.log('navBars init started');
  colorScale = d3.scale.linear().domain([0, navBarsData.length]).range([colors.scaleStart, colors.scaleEnd]);
  root = {
    'name': null,
    'element': textRectFactory(svgHookPoint),
    'parent': null,
    'nestLevel': -1,
    'viewStatus': 'visible'
  };
  initialViewStatus = function(bar) {
    if (bar.parentBar === null) {
      bar.viewStatus = 'visible';
    }
    if (bar.name === "AAA") {
      bar.viewStatus = 'selected';
      return bar.select();
    }
  };
  barCreate = function(svgHookPoint, barData, parentBar, baseColor) {
    var bar, nestLevel;
    if (parentBar === null) {
      nestLevel = 0;
    } else {
      nestLevel = parentBar.nestLevel + 1;
    }
    bar = {
      'name': barData.name,
      'display': barData.display,
      'element': textRectFactory(svgHookPoint, barData.name),
      'baseColor': baseColor,
      'parent': parentBar,
      'nestLevel': nestLevel,
      'viewStatus': 'hidden',
      'emphasis': barData.emphasis,
      'select': (function() {
        session.selected = this;
        sessionSetDisplayType(this);
        return window.setTimeout(textportRefresh, 300);
      })
    };
    initialViewStatus(bar);
    lookup[bar.element.group.attr('id')] = bar;
    /*
    # proceed to recursion over bar subs, if any
    if barData.subs?
      bar.children = []
      for barDataSub in barData.subs
        subBar = barCreate(svgHookPoint, barDataSub, bar, '#BBBBBB')
        bar.children.push(subBar)
    */

    bar.element.group.on('mouseover', function() {
      return null;
    }).on('mouseout', function() {
      return null;
    }).on('mousedown', function() {
      var child, sibling, _i, _j, _len, _len1, _ref, _ref1;
      bar = lookup[this.getAttribute('id')];
      if (bar.parent != null) {
        _ref = bar.parent.children;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          sibling = _ref[_i];
          if (sibling.viewStatus === 'selected') {
            barUnselect(sibling);
          }
        }
      }
      bar.viewStatus = 'selected';
      bar.select();
      if (bar.children != null) {
        _ref1 = bar.children;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          child = _ref1[_j];
          child.viewStatus = 'visible';
        }
      }
      return redraw(bars);
    });
    return bar;
  };
  for (i = _i = 0, _len = navBarsData.length; _i < _len; i = ++_i) {
    barData = navBarsData[i];
    bar = barCreate(svgHookPoint, barData, null, colorScale(i));
    bars.push(bar);
  }
  root.children = bars;
  _results = [];
  for (_j = 0, _len1 = bars.length; _j < _len1; _j++) {
    bar = bars[_j];
    _results.push(bar.parent = root);
  }
  return _results;
};

redraw = function(bars, borderColor) {
  var allowedGeometry, anySelected, bar, childGeometryPadding, height, i, textGeometry, visibleChildren, y, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _ref, _ref1;
  console.log('navBars redraw started');
  allowedGeometry = bars[0].parent.childrenGeometry;
  anySelected = false;
  for (_i = 0, _len = bars.length; _i < _len; _i++) {
    bar = bars[_i];
    if (bar.viewStatus === 'selected') {
      anySelected = true;
    }
  }
  for (_j = 0, _len1 = bars.length; _j < _len1; _j++) {
    bar = bars[_j];
    visibleChildren = false;
    if (bar.children != null) {
      if ((_ref = bar.children[0].viewStatus) === 'visible' || _ref === 'selected') {
        visibleChildren = true;
      }
    }
    switch (bar.viewStatus) {
      case 'selected':
        if (visibleChildren) {
          bar.color = bar.baseColor;
        } else {
          bar.color = colors.selection;
          bar.element.text.style('fill', 'EEEEEE').attr("font-size", "20px").style("font-weight", "bold");
        }
        break;
      default:
        bar.color = bar.baseColor;
        bar.element.text.style('fill', 'EEEEEE').attr("font-size", "16px").style("font-weight", "bold");
    }
  }
  if (anySelected) {
    for (_k = 0, _len2 = bars.length; _k < _len2; _k++) {
      bar = bars[_k];
      switch (bar.viewStatus) {
        case 'selected':
          bar.heightRatio = 'main';
          break;
        default:
          bar.heightRatio = 'subordinate';
      }
    }
  } else {
    for (_l = 0, _len3 = bars.length; _l < _len3; _l++) {
      bar = bars[_l];
      bar.heightRatio = 'even';
    }
  }
  y = allowedGeometry.y;
  for (i = _m = 0, _len4 = bars.length; _m < _len4; i = ++_m) {
    bar = bars[i];
    visibleChildren = false;
    if (bar.children != null) {
      if ((_ref1 = bar.children[0].viewStatus) === 'visible' || _ref1 === 'selected') {
        visibleChildren = true;
      }
    }
    switch (bar.heightRatio) {
      case 'main':
        height = Math.floor(allowedGeometry.height * (2 / 3));
        break;
      case 'subordinate':
        height = Math.floor(allowedGeometry.height * (1 / 3) / (bars.length - 1));
        break;
      case 'even':
        height = Math.floor(allowedGeometry.height / bars.length);
    }
    bar.geometry = {
      x: allowedGeometry.x,
      width: allowedGeometry.width,
      y: y + 0.5,
      height: height
    };
    if (bar.textPaddedSpace == null) {
      bar.textPaddedSpace = bar.geometry.height;
      bar.innerExtraPadding = {
        top: bar.textPaddedSpace * 1.5,
        bottom: bar.textPaddedSpace * 0.2
      };
    }
    bar.element.rectangle.transition().ease('linear').duration(400).attr(bar.geometry).style('fill', bar.color);
    if (visibleChildren) {
      childGeometryPadding = {
        x: 12,
        y: 5
      };
      bar.childrenGeometry = {
        x: bar.geometry.x + childGeometryPadding.x,
        width: bar.geometry.width - (childGeometryPadding.x * 1),
        y: bar.geometry.y + childGeometryPadding.y + bar.innerExtraPadding.top,
        height: bar.geometry.height - (childGeometryPadding.y * 2) - (bar.innerExtraPadding.top + bar.innerExtraPadding.bottom)
      };
      window.setTimeout(redraw, 400, bar.children);
      textGeometry = {
        'x': bar.geometry.x + (bar.geometry.width / 2),
        'y': bar.geometry.y + (bar.innerExtraPadding.top / 2)
      };
    } else {
      textGeometry = {
        'x': bar.geometry.x + (bar.geometry.width / 2),
        'y': bar.geometry.y + (bar.geometry.height / 2)
      };
    }
    bar.element.text.transition().ease('linear').duration(200).attr(textGeometry);
    bar.element.group.attr('visibility', 'visible');
    y += height;
  }
  return null;
};

exports.redraw = function(geometry) {
  root.geometry = geometry;
  root.childrenGeometry = {
    x: root.geometry.x,
    width: root.geometry.width,
    y: root.geometry.y,
    height: root.geometry.height
  };
  return redraw(bars);
};

/*

oldshow = () ->
  #
  # Show left panes and make them change on clicks (hackish style)
  #

  groupY = layout.separator.top.y - 0.5
  panes(groupY, totalH, layout.separator.left.x.current, sceneObject.categories.level1)

  groupY = totalH/2 + layout.separator.top.y - 0.5
  panes(groupY, totalH/2, layout.separator.left.x.current, sceneObject.categories.level2)


# console.log JSON.stringify(bar.childrenGeometry, null, '  ')
*/


},{"./globalDims":3,"./session":8,"./svgUtil":9,"./textportFluent":11,"./textportSegmented":12,"./tokenize":13,"./util":14}],6:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
var barUnselect, bars, categorizedTextTree, colors, getCategoryText, globalDims, layout, lookup, redraw, root, sceneObject, searchCategories, session, sessionSetDisplayType, svgUtil, textRectFactory, textportFluent, textportRefresh, textportSegmented, tokenize, util;

util = require('./util');

svgUtil = require('./svgUtil');

textportFluent = require('./textportFluent');

textportSegmented = require('./textportSegmented');

session = require('./session');

tokenize = require('./tokenize');

globalDims = require('./globalDims');

sceneObject = globalDims.sceneObject;

layout = globalDims.layout;

bars = [];

root = {};

lookup = {};

colors = {
  scaleStart: '#87CEFA',
  scaleEnd: '#00BFFF',
  selection: '#999999'
};

categorizedTextTree = void 0;

textRectFactory = function(svgHookPoint, rectText) {
  var styles;
  styles = {
    text: {
      'font-family': 'verdana',
      'fill': '#EEEEEE',
      'font-weight': 'bold'
    },
    rectangle: {
      'stroke-width': '0px',
      'fill-opacity': '1'
    }
  };
  return svgUtil.textRectFactory(svgHookPoint, rectText, styles, 'hidden');
};

searchCategories = function(categoryNodes, catName) {
  var categoryNode, _i, _len;
  for (_i = 0, _len = categoryNodes.length; _i < _len; _i++) {
    categoryNode = categoryNodes[_i];
    if (categoryNode.name === catName) {
      return categoryNode.text;
    } else {
      if (categoryNode.subs != null) {
        if (searchCategories(categoryNode.subs, catName)) {
          return searchCategories(categoryNode.subs, catName);
        }
      }
    }
  }
  return false;
};

getCategoryText = function(catName) {
  var text;
  return text = searchCategories(categorizedTextTree, catName);
};

textportRefresh = function(fontSizeChange, scroll, mode) {
  var rawSegment, rawSentence, rawTextArray, segment, segments, sentence, sentences, _i, _j, _len, _len1;
  rawTextArray = getCategoryText(session.selected.name);
  if (rawTextArray) {
    switch (session.display) {
      case 'segmented':
        segments = [];
        for (_i = 0, _len = rawTextArray.length; _i < _len; _i++) {
          rawSegment = rawTextArray[_i];
          segment = {
            category: null,
            tokens: tokenize(rawSegment)
          };
          segments.push(segment);
        }
        return textportSegmented(segments, fontSizeChange, scroll, mode);
      case 'fluent':
        sentences = [];
        for (_j = 0, _len1 = rawTextArray.length; _j < _len1; _j++) {
          rawSentence = rawTextArray[_j];
          sentence = {
            text: tokenize(rawSentence)
          };
          sentences.push(sentence);
        }
        return textportFluent(sentences, fontSizeChange, scroll, mode);
    }
  }
};

exports.textportRefresh = textportRefresh;

sessionSetDisplayType = function(bar) {
  if (bar.display === 'segmented') {
    return session.display = 'segmented';
  } else {
    return session.display = 'fluent';
  }
};

barUnselect = function(bar) {
  var hideChildren;
  hideChildren = function(bar) {
    var child, _i, _len, _ref, _results;
    if (bar.children != null) {
      _ref = bar.children;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        child = _ref[_i];
        child.viewStatus = 'hidden';
        child.element.group.attr('visibility', 'hidden');
        _results.push(hideChildren(child));
      }
      return _results;
    }
  };
  bar.viewStatus = 'visible';
  return hideChildren(bar);
};

exports.init = function(navBarsData, svgHookPoint, categorizedTextTreeInput) {
  var bar, barCreate, barData, colorScale, i, initialViewStatus, _i, _j, _len, _len1, _results;
  categorizedTextTree = categorizedTextTreeInput;
  console.log('navBars init started');
  colorScale = d3.scale.linear().domain([0, navBarsData.length]).range([colors.scaleStart, colors.scaleEnd]);
  root = {
    'name': null,
    'element': textRectFactory(svgHookPoint),
    'parent': null,
    'nestLevel': -1,
    'viewStatus': 'visible'
  };
  initialViewStatus = function(bar) {
    if (bar.parentBar === null) {
      bar.viewStatus = 'visible';
    }
    if (bar.name === "Abstract") {
      bar.viewStatus = 'selected';
      return bar.select();
    }
  };
  barCreate = function(svgHookPoint, barData, parentBar, baseColor) {
    var bar, barDataSub, nestLevel, subBar, _i, _len, _ref;
    if (parentBar === null) {
      nestLevel = 0;
    } else {
      nestLevel = parentBar.nestLevel + 1;
    }
    bar = {
      'name': barData.name,
      'display': barData.display,
      'element': textRectFactory(svgHookPoint, barData.name),
      'baseColor': baseColor,
      'parent': parentBar,
      'nestLevel': nestLevel,
      'viewStatus': 'hidden',
      'emphasis': barData.emphasis,
      'select': (function() {
        session.selected = this;
        sessionSetDisplayType(this);
        return textportRefresh();
      })
    };
    initialViewStatus(bar);
    lookup[bar.element.group.attr('id')] = bar;
    if (barData.subs != null) {
      bar.children = [];
      _ref = barData.subs;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        barDataSub = _ref[_i];
        subBar = barCreate(svgHookPoint, barDataSub, bar, '#BBBBBB');
        bar.children.push(subBar);
      }
    }
    bar.element.group.on('mouseover', function() {
      return null;
    }).on('mouseout', function() {
      return null;
    }).on('mousedown', function() {
      var child, sibling, _j, _k, _len1, _len2, _ref1, _ref2;
      bar = lookup[this.getAttribute('id')];
      if (bar.parent != null) {
        _ref1 = bar.parent.children;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          sibling = _ref1[_j];
          if (sibling.viewStatus === 'selected') {
            barUnselect(sibling);
          }
        }
      }
      bar.viewStatus = 'selected';
      bar.select();
      if (bar.children != null) {
        _ref2 = bar.children;
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          child = _ref2[_k];
          child.viewStatus = 'visible';
        }
      }
      return redraw(bars);
    });
    return bar;
  };
  for (i = _i = 0, _len = navBarsData.length; _i < _len; i = ++_i) {
    barData = navBarsData[i];
    bar = barCreate(svgHookPoint, barData, null, colorScale(i));
    bars.push(bar);
  }
  root.children = bars;
  _results = [];
  for (_j = 0, _len1 = bars.length; _j < _len1; _j++) {
    bar = bars[_j];
    _results.push(bar.parent = root);
  }
  return _results;
};

redraw = function(bars, borderColor) {
  var allowedGeometry, anySelected, bar, childGeometryPadding, height, i, textGeometry, visibleChildren, y, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _ref, _ref1;
  console.log('navBars redraw started');
  allowedGeometry = bars[0].parent.childrenGeometry;
  anySelected = false;
  for (_i = 0, _len = bars.length; _i < _len; _i++) {
    bar = bars[_i];
    if (bar.viewStatus === 'selected') {
      anySelected = true;
    }
  }
  for (_j = 0, _len1 = bars.length; _j < _len1; _j++) {
    bar = bars[_j];
    visibleChildren = false;
    if (bar.children != null) {
      if ((_ref = bar.children[0].viewStatus) === 'visible' || _ref === 'selected') {
        visibleChildren = true;
      }
    }
    switch (bar.viewStatus) {
      case 'selected':
        if (visibleChildren) {
          bar.color = bar.baseColor;
        } else {
          bar.color = colors.selection;
        }
        break;
      default:
        bar.color = bar.baseColor;
    }
    if (bar.emphasis != null) {
      bar.element.text.style("font-weight", "normal");
    }
  }
  if (anySelected) {
    for (_k = 0, _len2 = bars.length; _k < _len2; _k++) {
      bar = bars[_k];
      switch (bar.viewStatus) {
        case 'selected':
          bar.heightRatio = 'main';
          break;
        default:
          bar.heightRatio = 'subordinate';
      }
    }
  } else {
    for (_l = 0, _len3 = bars.length; _l < _len3; _l++) {
      bar = bars[_l];
      bar.heightRatio = 'even';
    }
  }
  y = allowedGeometry.y;
  for (i = _m = 0, _len4 = bars.length; _m < _len4; i = ++_m) {
    bar = bars[i];
    visibleChildren = false;
    if (bar.children != null) {
      if ((_ref1 = bar.children[0].viewStatus) === 'visible' || _ref1 === 'selected') {
        visibleChildren = true;
      }
    }
    switch (bar.heightRatio) {
      case 'main':
        height = Math.floor(allowedGeometry.height * (2 / 3));
        break;
      case 'subordinate':
        height = Math.floor(allowedGeometry.height * (1 / 3) / (bars.length - 1));
        break;
      case 'even':
        height = Math.floor(allowedGeometry.height / bars.length);
    }
    bar.geometry = {
      x: allowedGeometry.x,
      width: allowedGeometry.width,
      y: y + 0.5,
      height: height
    };
    if (bar.textPaddedSpace == null) {
      bar.textPaddedSpace = bar.geometry.height;
      bar.innerExtraPadding = {
        top: bar.textPaddedSpace * 1.5,
        bottom: bar.textPaddedSpace * 0.2
      };
    }
    bar.element.rectangle.transition().ease('linear').duration(400).attr(bar.geometry).style('fill', bar.color);
    if (visibleChildren) {
      childGeometryPadding = {
        x: 12,
        y: 5
      };
      bar.childrenGeometry = {
        x: bar.geometry.x + childGeometryPadding.x,
        width: bar.geometry.width - (childGeometryPadding.x * 1),
        y: bar.geometry.y + childGeometryPadding.y + bar.innerExtraPadding.top,
        height: bar.geometry.height - (childGeometryPadding.y * 2) - (bar.innerExtraPadding.top + bar.innerExtraPadding.bottom)
      };
      window.setTimeout(redraw, 400, bar.children);
      textGeometry = {
        'x': bar.geometry.x + (bar.geometry.width / 2),
        'y': bar.geometry.y + (bar.innerExtraPadding.top / 2)
      };
    } else {
      textGeometry = {
        'x': bar.geometry.x + (bar.geometry.width / 2),
        'y': bar.geometry.y + (bar.geometry.height / 2)
      };
    }
    bar.element.text.transition().ease('linear').duration(200).attr(textGeometry);
    bar.element.group.attr('visibility', 'visible');
    y += height;
  }
  return null;
};

exports.redraw = function(geometry) {
  root.geometry = geometry;
  root.childrenGeometry = {
    x: root.geometry.x,
    width: root.geometry.width,
    y: root.geometry.y,
    height: root.geometry.height
  };
  return redraw(bars);
};

/*

oldshow = () ->
  #
  # Show left panes and make them change on clicks (hackish style)
  #

  groupY = layout.separator.top.y - 0.5
  panes(groupY, totalH, layout.separator.left.x.current, sceneObject.categories.level1)

  groupY = totalH/2 + layout.separator.top.y - 0.5
  panes(groupY, totalH/2, layout.separator.left.x.current, sceneObject.categories.level2)


# console.log JSON.stringify(bar.childrenGeometry, null, '  ')
*/


},{"./globalDims":3,"./session":8,"./svgUtil":9,"./textportFluent":11,"./textportSegmented":12,"./tokenize":13,"./util":14}],7:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
var getPaneID, paneCounter;

paneCounter = 0;

getPaneID = function() {
  paneCounter += 1;
  return paneCounter;
};

exports.titlePaneCreate = function(svgAnchor, initialColor, rotated) {
  var paneObject, textWrapperId;
  paneObject = {};
  paneObject.element = svgAnchor.append('g');
  paneObject.pane = paneObject.element.append('rect').style('fill', initialColor);
  if (rotated) {
    textWrapperId = "panetextWrapper" + getPaneID();
    paneObject.element.append('foreignObject').append('xhtml:body').html("<svg id=" + textWrapperId + " style='-webkit-transform: perspective(40px) rotate3d(1, 0, 0, 2deg)'></svg>").style('pointer-events', 'none');
    paneObject.textWrapper = d3.select('#' + textWrapperId);
    paneObject.text = paneObject.textWrapper.append('text').attr("dominant-baseline", "central").style("text-anchor", "middle").style('fill', "#EEEEEE");
  } else {
    paneObject.text = paneObject.element.append('text').attr("dominant-baseline", "central").style("text-anchor", "middle").style('fill', "#EEEEEE");
  }
  return paneObject;
};

},{}],8:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
module.exports = {};

},{}],9:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
exports.textRectFactory = function(svgHookPoint, rectText, styles, visibility) {
  var group, rectangle, sceneObject, text, textDims;
  group = svgHookPoint.append('g').style('-webkit-user-select', 'none').style('-webkit-touch-callout', 'none').style('user-select', 'none').attr('id', rectText).attr('visibility', visibility);
  rectangle = group.append('rect').style(styles.rectangle);
  if (rectText != null) {
    text = group.append('text').text(rectText).attr("dominant-baseline", "central").style("text-anchor", "middle").style(styles.text);
    textDims = {
      width: text.node().getBBox().width,
      height: text.node().getBBox().height
    };
  } else {
    text = null;
  }
  sceneObject = {
    group: group,
    rectangle: rectangle,
    text: text,
    textDims: textDims
  };
  return sceneObject;
};

exports.sync = function(item, callback) {
  var attributesToTransition, key, stylesToTransition, val, _ref, _ref1, _ref2, _ref3, _results;
  if (item.mode) {
    console.log(item.mode);
  }
  if (item.mode === 'animate') {
    attributesToTransition = {};
    _ref = item.geometry;
    for (key in _ref) {
      val = _ref[key];
      if (key === 'x' || key === 'width' || key === 'y' || key === 'height' || key === 'rx' || key === 'ry') {
        if (parseFloat(item.element.attr(key)) !== val) {
          attributesToTransition[key] = val;
          console.dir('going to transition ' + key + ' from ' + item.element.attr(key) + ' to ' + val);
        }
      }
    }
    stylesToTransition = {};
    _ref1 = item.style;
    for (key in _ref1) {
      val = _ref1[key];
      if (item.element.style(key) !== val) {
        stylesToTransition[key] = val;
      }
    }
    if (callback != null) {
      return item.element.transition().duration(400).attr(attributesToTransition).style(stylesToTransition).each('end', callback);
    } else {
      return item.element.transition().duration(400).attr(attributesToTransition).style(stylesToTransition);
    }
  } else {
    _ref2 = item.geometry;
    for (key in _ref2) {
      val = _ref2[key];
      item.element.attr(key, val);
    }
    _ref3 = item.style;
    _results = [];
    for (key in _ref3) {
      val = _ref3[key];
      _results.push(item.element.style(key, val));
    }
    return _results;
  }
};

},{}],10:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
var globalDims, layout, sceneObject;

globalDims = require('./globalDims');

sceneObject = globalDims.sceneObject;

layout = globalDims.layout;

exports.tokenToViewable = function(token, visibleGroup) {
  var height, svgText, visualToken, width;
  visualToken = {};
  svgText = visibleGroup.append('text').attr('y', -500).attr('x', -500).style("dominant-baseline", "hanging");
  svgText.text(token);
  width = svgText.node().getBBox().width;
  height = svgText.node().getBBox().height;
  visualToken.svg = svgText;
  visualToken.height = height;
  visualToken.width = width;
  return visualToken;
};

},{"./globalDims":3}],11:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
var fontFamily, fontSize, globalDims, layout, sceneHook, sceneObject, session, textDraw, tokenize;

globalDims = require('./globalDims');

sceneObject = globalDims.sceneObject;

sceneHook = globalDims.sceneHook;

layout = globalDims.layout;

session = require('./session');

tokenize = require('./tokenize');

textDraw = require('./textDraw');

fontSize = '22px';

fontFamily = 'Helvetica';

module.exports = function(categorizedTextTree, fontSizeChange, scroll, mode) {
  var lHeight, paddingX, paddingY, redraw, spaceWidth;
  if (scroll != null) {
    console.log(scroll);
    sceneObject.textPortInnerSVG.element.transition().ease('sin').duration(2000).attr('y', 0);
    return;
  }
  console.log('fluent textPorting started ' + '(mode ' + mode + ')');
  if (fontSizeChange != null) {
    fontSize = parseFloat(fontSize) + fontSizeChange + 'px';
  }
  if (sceneObject.textPortInnerSVG != null) {
    sceneObject.textPortInnerSVG.element.remove();
  }
  sceneObject.textPortInnerSVG = {};
  sceneObject.textPortInnerSVG.element = sceneHook.svg.append('svg');
  sceneObject.textPortInnerSVG.subElement = sceneObject.textPortInnerSVG.element.append('g').style('text-anchor', 'start').style('fill', 'rgb(220,220,220)').style('font-family', fontFamily).style('font-size', fontSize);
  spaceWidth = textDraw.tokenToViewable('a a', sceneObject.textPortInnerSVG.subElement).width - textDraw.tokenToViewable('aa', sceneObject.textPortInnerSVG.subElement).width;
  spaceWidth *= 1.4;
  lHeight = textDraw.tokenToViewable('l', sceneObject.textPortInnerSVG.subElement).height;
  paddingX = 20;
  paddingY = 18;
  sceneObject.textPortInnerSVG.element.attr('x', parseFloat(sceneObject.textPort.element.attr('x')) + paddingX + 3).attr('width', parseFloat(sceneObject.textPort.element.attr('width') - (paddingX * 2) - 3)).attr('y', parseFloat(sceneObject.textPort.element.attr('y')) + paddingY).attr('height', parseFloat(sceneObject.textPort.element.attr('height') - (paddingY * 2) - 50));
  redraw = function() {
    var categoryNode, rawSentence, sentence, sentences, subCategory, token, tokenViewable, viewPortFull, x, y, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _ref, _ref1, _ref2;
    viewPortFull = false;
    x = 0;
    y = 0;
    for (_i = 0, _len = categorizedTextTree.length; _i < _len; _i++) {
      categoryNode = categorizedTextTree[_i];
      if (categoryNode.name === session.selected.name) {
        console.log("categroy " + session.selected.name + " found");
        _ref = categoryNode.subs;
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          subCategory = _ref[_j];
          if (y !== 0) {
            y += 30;
          }
          tokenViewable = textDraw.tokenToViewable(subCategory.name, sceneObject.textPortInnerSVG.subElement);
          tokenViewable.svg.attr('x', sceneObject.textPortInnerSVG.element.attr('width') / 2).attr('y', y).style("text-anchor", "middle").attr("dominant-baseline", "central").style("font-family", "Helvetica").style("font-weight", "bold").attr("font-size", "30px").style('fill', '#aaaaaa');
          y += 40;
          sentences = [];
          _ref1 = subCategory.text;
          for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
            rawSentence = _ref1[_k];
            sentence = {
              text: tokenize(rawSentence)
            };
            sentences.push(sentence);
          }
          console.log("subcategory " + subCategory.name + " being handled");
          for (_l = 0, _len3 = sentences.length; _l < _len3; _l++) {
            sentence = sentences[_l];
            _ref2 = sentence.text;
            for (_m = 0, _len4 = _ref2.length; _m < _len4; _m++) {
              token = _ref2[_m];
              console.log(token.text);
              tokenViewable = textDraw.tokenToViewable(token.text, sceneObject.textPortInnerSVG.subElement);
              switch (token.mark) {
                case 1:
                  tokenViewable.svg.style('fill', '#4488FE');
                  break;
                case 2:
                  tokenViewable.svg.style('fill', '#4488FE').style('font-style', 'italic');
              }
              if (x + tokenViewable.width < sceneObject.textPortInnerSVG.element.attr('width')) {
                tokenViewable.svg.attr('x', x).attr('y', y);
                x += tokenViewable.width;
              } else {
                if (y + tokenViewable.height + lHeight < sceneObject.textPortInnerSVG.element.attr('height')) {
                  x = 0;
                  y += tokenViewable.height;
                  tokenViewable.svg.attr('x', x).attr('y', y);
                  x += tokenViewable.width;
                } else {
                  console.log('text port full');
                  viewPortFull = true;
                  break;
                }
              }
              if (x + spaceWidth < sceneObject.textPortInnerSVG.element.attr('width')) {
                x += spaceWidth;
              }
            }
            y += tokenViewable.height * 2;
            x = 0;
          }
        }
      }
    }
    return viewPortFull;
  };
  return redraw();
};

},{"./globalDims":3,"./session":8,"./textDraw":10,"./tokenize":13}],12:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
var fontFamily, fontSize, globalDims, layout, sceneHook, sceneObject, session, svgUtil, textDraw;

globalDims = require('./globalDims');

sceneObject = globalDims.sceneObject;

sceneHook = globalDims.sceneHook;

layout = globalDims.layout;

svgUtil = require('./svgUtil');

session = require('./session');

textDraw = require('./textDraw');

fontSize = '18px';

fontFamily = 'Helvetica';

module.exports = function(segments, fontSizeChange, scroll, mode) {
  var enclosing, lHeight, paddingX, paddingY, redraw, spaceWidth;
  console.log('segmented textPorting started ' + '(mode ' + mode + ')');
  if (fontSizeChange != null) {
    fontSize = parseFloat(fontSize) + fontSizeChange + 'px';
  }
  if (sceneObject.textPortInnerSVG != null) {
    sceneObject.textPortInnerSVG.element.remove();
  }
  sceneObject.textPortInnerSVG = {};
  sceneObject.textPortInnerSVG.element = sceneHook.svg.append('svg');
  sceneObject.textPortInnerSVG.subElement = sceneObject.textPortInnerSVG.element.append('g').style('text-anchor', 'start').style('font-family', fontFamily).style('font-size', fontSize);
  spaceWidth = textDraw.tokenToViewable('a a', sceneObject.textPortInnerSVG.subElement).width - textDraw.tokenToViewable('aa', sceneObject.textPortInnerSVG.subElement).width;
  spaceWidth *= 1.4;
  lHeight = textDraw.tokenToViewable('l', sceneObject.textPortInnerSVG.subElement).height;
  paddingX = 20;
  paddingY = 18;
  enclosing = {
    paddingX: 15,
    paddingY: 15
  };
  segments.spacingY = 20;
  sceneObject.textPortInnerSVG.element.attr('x', parseFloat(sceneObject.textPort.element.attr('x')) + paddingX + 3).attr('width', parseFloat(sceneObject.textPort.element.attr('width') - (paddingX * 2) - 3)).attr('y', parseFloat(sceneObject.textPort.element.attr('y')) + paddingY).attr('height', parseFloat(sceneObject.textPort.element.attr('height') - (paddingY * 2) - 50));
  redraw = function() {
    var segment, segmentTokens, textToken, tokenViewable, viewPortFull, x, y, _i, _j, _len, _len1, _ref, _results;
    viewPortFull = false;
    y = enclosing.paddingY;
    _results = [];
    for (_i = 0, _len = segments.length; _i < _len; _i++) {
      segment = segments[_i];
      segment.element = sceneObject.textPortInnerSVG.subElement.append('g').style('text-anchor', 'start').style('fill', '#EEEEEE').style('font-family', fontFamily).style('font-size', fontSize);
      segment.enclosure = {};
      segment.enclosure.element = segment.element.append('rect').style('opacity', 0.9).style('fill', '#555555');
      segmentTokens = [];
      x = enclosing.paddingX;
      segment.enclosure.geometry = {
        'rx': 7,
        'ry': 5,
        'y': y - enclosing.paddingY,
        'x': x - enclosing.paddingX,
        'width': sceneObject.textPortInnerSVG.element.attr('width')
      };
      _ref = segment.tokens;
      for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
        textToken = _ref[_j];
        tokenViewable = textDraw.tokenToViewable(textToken.text, segment.element);
        switch (textToken.mark) {
          case 1:
            tokenViewable.svg.style('fill', '#5599FE');
            break;
          case 2:
            tokenViewable.svg.style('fill', 'rgb(100,220,220)');
        }
        if (x + tokenViewable.width < sceneObject.textPortInnerSVG.element.attr('width') - enclosing.paddingX) {
          tokenViewable.svg.attr('x', x);
          tokenViewable.svg.attr('y', y);
          x += tokenViewable.width;
        } else {
          if (y + tokenViewable.height + lHeight < sceneObject.textPortInnerSVG.element.attr('height')) {
            x = enclosing.paddingX;
            y += tokenViewable.height;
            tokenViewable.svg.attr('x', x);
            tokenViewable.svg.attr('y', y);
            x += tokenViewable.width;
          } else {
            viewPortFull = true;
            break;
          }
        }
        if (x + spaceWidth < sceneObject.textPortInnerSVG.element.attr('width')) {
          x += spaceWidth;
        }
      }
      y += lHeight + enclosing.paddingY;
      segment.enclosure.geometry.height = y - segment.enclosure.geometry.y;
      svgUtil.sync(segment.enclosure);
      _results.push(y += segments.spacingY);
    }
    return _results;
  };
  return redraw();
};

},{"./globalDims":3,"./session":8,"./svgUtil":9,"./textDraw":10}],13:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
var old;

module.exports = function(text) {
  var t, textArray, token, tokens, _i, _len;
  textArray = text.split(' ');
  tokens = [];
  for (t = _i = 0, _len = textArray.length; _i < _len; t = ++_i) {
    token = textArray[t];
    if (token.charAt(0) === '<' && (token.charAt(1) != null) && token.charAt(1) === '<') {
      tokens.push({
        'text': token.substr(2, token.length - 4),
        'mark': 2
      });
      continue;
    }
    if (token.charAt(0) === '<' && token.charAt(token.length - 1) === '>') {
      tokens.push({
        'text': token.substr(1, token.length - 2),
        'mark': 1
      });
      continue;
    }
    tokens.push({
      'text': token,
      'mark': 0
    });
  }
  return tokens;
};

old = function(text) {
  var t, textArray, tokens, _i, _ref;
  textArray = text.split(' ');
  tokens = [];
  for (t = _i = 0, _ref = textArray.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; t = 0 <= _ref ? ++_i : --_i) {
    /*
    if input.marks?
      tokens.push 
        'text': textArray[t],
        'mark': markeringCodes[t]
    else
    */

    tokens.push({
      'text': textArray[t],
      'mark': 0
    });
  }
  return tokens;
};

},{}],14:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
exports.getViewport = function() {
  return {
    width: window.innerWidth,
    height: window.innerHeight
  };
};

exports.calcLength = function(i1, i2) {
  return i2 - i1 + 1;
};

exports.makeSvgTopLayer = function(element) {
  return element.parentNode.appendChild(element);
};

},{}]},{},[2])